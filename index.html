<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>서희봇 - 도서관 도슨트</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 2px solid #0f3460;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 10px;
        }

        header p {
            color: #a0a0a0;
            font-size: 1.1em;
        }

        .status-bar {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 30px;
        }

        .status-item {
            background: rgba(255,255,255,0.1);
            padding: 15px 25px;
            border-radius: 15px;
            text-align: center;
            min-width: 150px;
            backdrop-filter: blur(10px);
        }

        .status-item .label {
            font-size: 0.9em;
            color: #a0a0a0;
            margin-bottom: 5px;
        }

        .status-item .value {
            font-size: 1.5em;
            font-weight: bold;
            color: #4ecca3;
        }

        .status-item .value.warning {
            color: #ffc107;
        }

        .status-item .value.danger {
            color: #e94560;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .map-section {
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 20px;
            position: relative;
        }

        .map-container {
            background: #0a0a15;
            border-radius: 15px;
            height: 500px;
            position: relative;
            overflow: hidden;
            border: 2px solid #0f3460;
        }

        .map-canvas {
            width: 100%;
            height: 100%;
        }

        .control-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel {
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 20px;
        }

        .panel h3 {
            color: #e94560;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 10px;
        }

        .waypoint-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .waypoint-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .waypoint-item:hover {
            background: rgba(78, 204, 163, 0.2);
            transform: translateX(5px);
        }

        .waypoint-item.active {
            background: rgba(233, 69, 96, 0.3);
            border-left: 3px solid #e94560;
        }

        .waypoint-item .name {
            font-weight: 500;
        }

        .waypoint-item .type {
            font-size: 0.8em;
            color: #a0a0a0;
        }

        .waypoint-item .go-btn {
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .waypoint-item .go-btn:hover {
            background: #3db892;
            transform: scale(1.05);
        }

        .quick-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .action-btn {
            padding: 15px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .action-btn.home {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .action-btn.stop {
            background: #e94560;
            color: #fff;
            grid-column: span 2;
        }

        .action-btn.pause {
            background: #ffc107;
            color: #1a1a2e;
        }

        .action-btn.resume {
            background: #17a2b8;
            color: #fff;
        }

        .log-section {
            margin-top: 30px;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 20px;
        }

        .log-section h3 {
            color: #e94560;
            margin-bottom: 15px;
        }

        .log-container {
            background: #0a0a15;
            border-radius: 10px;
            padding: 15px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #1a1a2e;
        }

        .log-entry .time {
            color: #666;
            margin-right: 10px;
        }

        .log-entry.success {
            color: #4ecca3;
        }

        .log-entry.error {
            color: #e94560;
        }

        .log-entry.info {
            color: #17a2b8;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .connection-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #e94560;
            animation: pulse 2s infinite;
        }

        .connection-dot.connected {
            background: #4ecca3;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Audio announcement banner */
        .announcement-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(90deg, #e94560, #4ecca3);
            color: #fff;
            padding: 15px;
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            transform: translateY(-100%);
            transition: transform 0.5s ease;
            z-index: 1000;
        }

        .announcement-banner.show {
            transform: translateY(0);
        }

        /* Settings modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #1a1a2e;
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            color: #e94560;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #a0a0a0;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #0f3460;
            border-radius: 10px;
            background: #0a0a15;
            color: #fff;
            font-size: 1em;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #4ecca3;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
        }

        .btn-primary {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .btn-secondary {
            background: #0f3460;
            color: #fff;
        }

        .settings-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #0f3460;
            color: #fff;
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.5em;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        /* Robot marker on map */
        .robot-marker {
            position: absolute;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            z-index: 100;
        }

        .robot-marker svg {
            width: 100%;
            height: 100%;
            fill: #e94560;
            filter: drop-shadow(0 0 5px rgba(233, 69, 96, 0.5));
        }

        .waypoint-marker {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #4ecca3;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            border: 3px solid #fff;
            z-index: 50;
            transition: all 0.3s ease;
        }

        .waypoint-marker:hover {
            transform: translate(-50%, -50%) scale(1.3);
        }

        .waypoint-marker.charge {
            background: #ffc107;
        }

        .waypoint-label {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.8em;
            white-space: nowrap;
            transform: translate(-50%, -150%);
            pointer-events: none;
        }

        /* Route styles */
        .action-btn.route {
            background: #9b59b6;
            color: #fff;
        }

        .route-select-container {
            margin-top: 10px;
        }

        .route-select {
            width: 100%;
            padding: 12px;
            border: 2px solid #0f3460;
            border-radius: 10px;
            background: #0a0a15;
            color: #fff;
            font-size: 1em;
            margin-bottom: 10px;
        }

        .route-select:focus {
            outline: none;
            border-color: #9b59b6;
        }

        .route-modal-content {
            max-width: 600px;
        }

        .route-point-list {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0a15;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .route-point-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: move;
            transition: all 0.2s ease;
        }

        .route-point-item:hover {
            background: rgba(155, 89, 182, 0.2);
        }

        .route-point-item.dragging {
            opacity: 0.5;
            background: rgba(155, 89, 182, 0.4);
        }

        .route-point-item .point-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .route-point-item .point-order {
            width: 28px;
            height: 28px;
            background: #9b59b6;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
        }

        .route-point-item .point-name {
            font-weight: 500;
        }

        .route-point-item .point-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .route-point-item .stay-time-input {
            width: 60px;
            padding: 6px;
            border: 1px solid #0f3460;
            border-radius: 5px;
            background: #1a1a2e;
            color: #fff;
            text-align: center;
        }

        .route-point-item .stay-time-label {
            font-size: 0.85em;
            color: #a0a0a0;
        }

        .route-point-item .move-btns {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .route-point-item .move-btn {
            background: #0f3460;
            border: none;
            color: #fff;
            width: 24px;
            height: 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .route-point-item .move-btn:hover {
            background: #4ecca3;
        }

        .route-point-item .remove-btn {
            background: #e94560;
            border: none;
            color: #fff;
            width: 28px;
            height: 28px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
        }

        .route-point-item .remove-btn:hover {
            background: #c0392b;
        }

        .available-points {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }

        .available-point-btn {
            padding: 8px 15px;
            background: #0f3460;
            border: none;
            color: #fff;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .available-point-btn:hover {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .available-point-btn.in-route {
            background: #9b59b6;
        }

        .route-name-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #0f3460;
            border-radius: 10px;
            background: #0a0a15;
            color: #fff;
            font-size: 1em;
            margin-bottom: 15px;
        }

        .route-name-input:focus {
            outline: none;
            border-color: #9b59b6;
        }

        .route-status {
            background: rgba(155, 89, 182, 0.2);
            border: 2px solid #9b59b6;
            border-radius: 10px;
            padding: 15px;
            margin-top: 10px;
            display: none;
        }

        .route-status.active {
            display: block;
        }

        .route-status .status-title {
            font-weight: bold;
            color: #9b59b6;
            margin-bottom: 8px;
        }

        .route-status .status-info {
            display: flex;
            justify-content: space-between;
            color: #a0a0a0;
            font-size: 0.9em;
        }

        .route-progress {
            width: 100%;
            height: 8px;
            background: #0f3460;
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
        }

        .route-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #9b59b6, #4ecca3);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .action-btn.stop-route {
            background: #e74c3c;
            color: #fff;
            display: none;
        }

        .action-btn.stop-route.active {
            display: flex;
        }

        .action-btn.charge {
            background: #f39c12;
            color: #1a1a2e;
        }

        .action-btn.speech {
            background: #3498db;
            color: #fff;
        }

        /* Footer styles */
        footer {
            background: rgba(0,0,0,0.3);
            padding: 20px;
            margin-top: 30px;
            border-radius: 20px;
            text-align: center;
        }

        footer .footer-content {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            flex-wrap: wrap;
            color: #a0a0a0;
            font-size: 0.9em;
        }

        footer .footer-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        footer .footer-item.library {
            color: #4ecca3;
            font-weight: bold;
            font-size: 1.1em;
        }

        footer a {
            color: #e94560;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Delete button for waypoints */
        .waypoint-item .del-btn {
            background: #e94560;
            color: #fff;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            margin-left: 8px;
            transition: all 0.3s ease;
        }

        .waypoint-item .del-btn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        .waypoint-item .btn-group {
            display: flex;
            gap: 5px;
        }

        /* Zone management styles */
        .zone-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .zone-item {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
        }

        .zone-item .zone-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .zone-item .zone-name {
            font-weight: bold;
            font-size: 1.1em;
            color: #3498db;
        }

        .zone-item .zone-point {
            font-size: 0.85em;
            color: #a0a0a0;
        }

        .zone-item .zone-speech {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            border: 1px solid #0f3460;
            border-radius: 8px;
            background: #0a0a15;
            color: #fff;
            font-size: 0.95em;
            resize: vertical;
            font-family: inherit;
        }

        .zone-item .zone-speech:focus {
            outline: none;
            border-color: #3498db;
        }

        .zone-item .zone-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
        }

        .zone-item .zone-controls select {
            flex: 1;
            padding: 8px;
            border: 1px solid #0f3460;
            border-radius: 6px;
            background: #1a1a2e;
            color: #fff;
        }

        .zone-item .test-btn {
            background: #3498db;
            color: #fff;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .zone-item .test-btn:hover {
            background: #2980b9;
        }

        .zone-badge {
            display: inline-block;
            background: #3498db;
            color: #fff;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            margin-left: 8px;
        }

        /* Build Map Mode Styles */
        .action-btn.build-map {
            background: #16c784;
            color: #fff;
        }

        .build-map-modal-content {
            max-width: 800px;
            width: 95%;
        }

        .build-map-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .build-map-header h2 {
            margin: 0;
        }

        .build-mode-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 15px;
            background: rgba(22, 199, 132, 0.2);
            border: 2px solid #16c784;
            border-radius: 10px;
        }

        .build-mode-indicator.inactive {
            background: rgba(233, 69, 96, 0.2);
            border-color: #e94560;
        }

        .build-mode-indicator .indicator-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #16c784;
            animation: pulse 1.5s infinite;
        }

        .build-mode-indicator.inactive .indicator-dot {
            background: #e94560;
            animation: none;
        }

        .build-map-layout {
            display: grid;
            grid-template-columns: 1fr 280px;
            gap: 20px;
        }

        @media (max-width: 700px) {
            .build-map-layout {
                grid-template-columns: 1fr;
            }
        }

        .build-map-preview {
            background: #0a0a15;
            border-radius: 15px;
            height: 400px;
            position: relative;
            overflow: hidden;
            border: 2px solid #16c784;
        }

        .build-map-preview canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        .build-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* Jog Dial / D-Pad Style */
        .jog-dial-container {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
        }

        .jog-dial-container h4 {
            color: #16c784;
            margin-bottom: 15px;
            text-align: center;
        }

        .jog-dial {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            width: 180px;
            height: 180px;
            margin: 0 auto;
        }

        .jog-btn {
            background: #0f3460;
            border: none;
            border-radius: 10px;
            color: #fff;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .jog-btn:hover {
            background: #16c784;
            transform: scale(1.05);
        }

        .jog-btn:active {
            background: #0d9c63;
            transform: scale(0.95);
        }

        .jog-btn.forward { grid-column: 2; grid-row: 1; }
        .jog-btn.left { grid-column: 1; grid-row: 2; }
        .jog-btn.stop-jog { grid-column: 2; grid-row: 2; background: #e94560; }
        .jog-btn.stop-jog:hover { background: #c0392b; }
        .jog-btn.right { grid-column: 3; grid-row: 2; }
        .jog-btn.backward { grid-column: 2; grid-row: 3; }
        .jog-btn.rotate-left { grid-column: 1; grid-row: 1; font-size: 1.2em; }
        .jog-btn.rotate-right { grid-column: 3; grid-row: 1; font-size: 1.2em; }

        /* Speed Control */
        .speed-control {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
        }

        .speed-control label {
            display: block;
            color: #a0a0a0;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .speed-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #0f3460;
            outline: none;
            -webkit-appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #16c784;
            cursor: pointer;
        }

        .speed-value {
            text-align: center;
            color: #16c784;
            font-weight: bold;
            margin-top: 5px;
        }

        /* Waypoint Capture */
        .waypoint-capture {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
        }

        .waypoint-capture h4 {
            color: #4ecca3;
            margin-bottom: 10px;
        }

        .waypoint-capture input {
            width: 100%;
            padding: 10px;
            border: 2px solid #0f3460;
            border-radius: 8px;
            background: #0a0a15;
            color: #fff;
            margin-bottom: 10px;
        }

        .waypoint-capture input:focus {
            outline: none;
            border-color: #4ecca3;
        }

        .capture-btn {
            width: 100%;
            padding: 12px;
            background: #4ecca3;
            color: #1a1a2e;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .capture-btn:hover {
            background: #3db892;
            transform: translateY(-2px);
        }

        /* Captured Points List */
        .captured-points {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            max-height: 150px;
            overflow-y: auto;
        }

        .captured-points h4 {
            color: #ffc107;
            margin-bottom: 10px;
        }

        .captured-point-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .captured-point-item .coords {
            color: #a0a0a0;
            font-size: 0.8em;
        }

        .captured-point-item .remove-captured {
            background: #e94560;
            border: none;
            color: #fff;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
        }

        /* Map Actions */
        .map-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .map-actions .btn {
            padding: 12px;
            font-size: 0.95em;
        }

        .map-actions .btn-save {
            background: #16c784;
            color: #fff;
        }

        .map-actions .btn-reset {
            background: #e94560;
            color: #fff;
        }

        /* Robot Position Display */
        .robot-position-display {
            background: rgba(22, 199, 132, 0.1);
            border: 1px solid #16c784;
            border-radius: 10px;
            padding: 10px 15px;
            margin-bottom: 15px;
            text-align: center;
        }

        .robot-position-display .pos-label {
            color: #a0a0a0;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .robot-position-display .pos-values {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-family: monospace;
            color: #16c784;
        }

        /* E-Stop Warning Banner */
        .estop-warning {
            background: linear-gradient(90deg, #e94560, #ffc107);
            color: #1a1a2e;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            margin-bottom: 15px;
            animation: estopPulse 1s infinite;
        }

        @keyframes estopPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* Saved Maps List Modal */
        .saved-maps-list {
            max-height: 300px;
            overflow-y: auto;
            background: #0a0a15;
            border-radius: 10px;
            padding: 10px;
        }

        .saved-map-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .saved-map-item:hover {
            background: rgba(22, 199, 132, 0.2);
        }

        .saved-map-item.active {
            background: rgba(22, 199, 132, 0.3);
            border-left: 3px solid #16c784;
        }

        .saved-map-item .map-info {
            flex: 1;
        }

        .saved-map-item .map-name {
            font-weight: bold;
            color: #16c784;
        }

        .saved-map-item .map-date {
            font-size: 0.8em;
            color: #a0a0a0;
        }

        .saved-map-item .map-points-count {
            font-size: 0.85em;
            color: #ffc107;
        }
    </style>
</head>
<body>
    <div class="announcement-banner" id="announcementBanner">
        도서관에 오신 것을 환영합니다!
    </div>

    <div class="container">
        <header>
            <h1>서희봇 - 도서관 도슨트</h1>
            <p>자율주행 안내 로봇 제어판</p>
            <div class="connection-status">
                <span class="connection-dot" id="connectionDot"></span>
                <span id="connectionText">연결 중...</span>
            </div>
        </header>

        <div class="status-bar">
            <div class="status-item">
                <div class="label">배터리</div>
                <div class="value" id="batteryLevel">--</div>
            </div>
            <div class="status-item">
                <div class="label">상태</div>
                <div class="value" id="robotStatus">--</div>
            </div>
            <div class="status-item">
                <div class="label">현재 목적지</div>
                <div class="value" id="currentGoal">--</div>
            </div>
            <div class="status-item">
                <div class="label">거리</div>
                <div class="value" id="distanceToGoal">--</div>
            </div>
        </div>

        <div class="main-content">
            <div class="map-section">
                <h3 style="color: #e94560; margin-bottom: 15px;">도서관 지도</h3>
                <div class="map-container" id="mapContainer">
                    <canvas class="map-canvas" id="mapCanvas"></canvas>
                    <div class="robot-marker" id="robotMarker">
                        <svg viewBox="0 0 24 24">
                            <path d="M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z"/>
                        </svg>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <div class="panel">
                    <h3>빠른 동작</h3>
                    <div class="quick-actions">
                        <button class="action-btn home" onclick="goHome()">
                            <span>홈</span>
                        </button>
                        <button class="action-btn charge" onclick="goCharge()">
                            <span>충전</span>
                        </button>
                        <button class="action-btn route" onclick="openRouteModal()">
                            <span>경로</span>
                        </button>
                        <button class="action-btn build-map" onclick="openBuildMapModal()">
                            <span>지도제작</span>
                        </button>
                        <button class="action-btn speech" onclick="openSpeechModal()">
                            <span>음성</span>
                        </button>
                        <button class="action-btn pause" onclick="pauseNavigation()">
                            <span>일시정지</span>
                        </button>
                        <button class="action-btn resume" onclick="resumeNavigation()">
                            <span>재개</span>
                        </button>
                        <button class="action-btn stop-route" id="stopRouteBtn" onclick="stopRoute()">
                            <span>경로 중지</span>
                        </button>
                        <button class="action-btn stop" onclick="stopNavigation()">
                            <span>긴급 정지</span>
                        </button>
                    </div>
                    <div class="route-select-container">
                        <select class="route-select" id="routeSelect" onchange="onRouteSelect()">
                            <option value="">-- 실행할 경로 선택 --</option>
                        </select>
                        <button class="btn btn-primary" onclick="startSelectedRoute()" style="width:100%">
                            경로 시작
                        </button>
                    </div>
                    <div class="route-status" id="routeStatus">
                        <div class="status-title">경로 진행 상황</div>
                        <div class="status-info">
                            <span id="routeCurrentPoint">--</span>
                            <span id="routeProgress">0 / 0</span>
                        </div>
                        <div class="route-progress">
                            <div class="route-progress-bar" id="routeProgressBar" style="width: 0%"></div>
                        </div>
                        <div class="status-info" style="margin-top: 8px">
                            <span>대기 시간:</span>
                            <span id="routeStayTime">--</span>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <h3>도서관 구역</h3>
                    <div class="waypoint-list" id="waypointList">
                        <!-- Waypoints will be loaded here -->
                    </div>
                </div>

                <div class="panel">
                    <h3>새 위치 추가</h3>
                    <div class="form-group">
                        <label>위치 이름</label>
                        <input type="text" id="newWaypointName" placeholder="예: 문학 코너">
                    </div>
                    <button class="btn btn-primary" onclick="addCurrentLocation()" style="width:100%">
                        현재 위치 저장
                    </button>
                </div>
            </div>
        </div>

        <div class="log-section">
            <h3>활동 로그</h3>
            <div class="log-container" id="logContainer">
                <!-- Logs will appear here -->
            </div>
        </div>

        <footer>
            <div class="footer-content">
                <div class="footer-item library">이천서희도서관</div>
                <div class="footer-item">제작: 주식회사 모아</div>
                <div class="footer-item">관리문의: <a href="mailto:peacej@naver.com">peacej@naver.com</a></div>
            </div>
        </footer>
    </div>

    <!-- Settings Modal -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <h2>설정</h2>
            <div class="form-group">
                <label>로봇 IP 주소</label>
                <input type="text" id="amrIpInput" value="192.168.219.42">
            </div>
            <div class="form-group">
                <label>이동 속도</label>
                <select id="navSpeedSelect">
                    <option value="0.3">느림 (0.3 m/s)</option>
                    <option value="0.5" selected>보통 (0.5 m/s)</option>
                    <option value="0.8">빠름 (0.8 m/s)</option>
                </select>
            </div>
            <div class="form-group">
                <label>음성 안내</label>
                <select id="voiceEnabledSelect">
                    <option value="true" selected>사용</option>
                    <option value="false">사용 안 함</option>
                </select>
            </div>
            <div class="form-group">
                <label>TTS 음성 선택</label>
                <select id="ttsVoiceSelect">
                    <option value="ko-KR-Wavenet-A">여성 (Wavenet A)</option>
                    <option value="ko-KR-Wavenet-B">여성 (Wavenet B)</option>
                    <option value="ko-KR-Wavenet-C">남성 (Wavenet C)</option>
                    <option value="ko-KR-Wavenet-D">남성 (Wavenet D)</option>
                    <option value="ko-KR-Neural2-A">여성 (Neural2 A) - 고품질</option>
                    <option value="ko-KR-Neural2-B">여성 (Neural2 B) - 고품질</option>
                    <option value="ko-KR-Neural2-C">남성 (Neural2 C) - 고품질</option>
                    <option value="ko-KR-Standard-A">여성 (Standard A)</option>
                    <option value="ko-KR-Standard-B">여성 (Standard B)</option>
                    <option value="ko-KR-Standard-C">남성 (Standard C)</option>
                    <option value="ko-KR-Standard-D">남성 (Standard D)</option>
                </select>
            </div>
            <div class="form-group">
                <label>TTS 속도 (0.5~2.0)</label>
                <input type="range" id="ttsRateInput" min="0.5" max="2.0" step="0.1" value="1.0" style="width:100%">
                <span id="ttsRateValue">1.0</span>
            </div>
            <div class="form-group">
                <label>TTS 테스트</label>
                <button class="btn btn-secondary" onclick="testTTS()" style="width:100%">테스트 재생</button>
            </div>

            <h3 style="color: #ffc107; margin: 20px 0 15px; border-top: 1px solid #333; padding-top: 15px;">충전 도킹 설정</h3>

            <div class="form-group">
                <label>도킹 방향</label>
                <select id="dockingDirectionSelect">
                    <option value="0">전진 도킹 (앞으로)</option>
                    <option value="1">후진 도킹 (뒤로)</option>
                </select>
            </div>
            <div class="form-group">
                <label>도킹 거리 (m) - 음수: 후진, 양수: 전진</label>
                <input type="number" id="dockingDistanceInput" value="-0.7" step="0.1" min="-2" max="2" style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #333; background: #1a1a2e; color: #fff;">
                <small style="color: #a0a0a0;">예: -0.7 = 70cm 후진하여 도킹</small>
            </div>
            <div class="form-group">
                <button class="btn btn-secondary" onclick="loadDockingSettings()" style="width:48%; margin-right: 4%;">현재값 불러오기</button>
                <button class="btn btn-primary" onclick="saveDockingSettings()" style="width:48%;">도킹 설정 저장</button>
            </div>

            <div class="btn-row" style="margin-top: 20px;">
                <button class="btn btn-secondary" onclick="closeSettings()">취소</button>
                <button class="btn btn-primary" onclick="saveSettings()">저장</button>
            </div>
        </div>
    </div>

    <!-- Route Creation Modal -->
    <div class="modal" id="routeModal">
        <div class="modal-content route-modal-content">
            <h2>경로 생성 / 편집</h2>

            <div class="form-group">
                <label>경로 이름</label>
                <input type="text" class="route-name-input" id="routeNameInput" placeholder="경로 이름 입력...">
            </div>

            <div class="form-group">
                <label>사용 가능한 위치 (클릭하여 추가)</label>
                <div class="available-points" id="availablePoints">
                    <!-- Available points will be rendered here -->
                </div>
            </div>

            <div class="form-group">
                <label>경로 순서 (드래그하여 재정렬)</label>
                <div class="route-point-list" id="routePointList">
                    <div style="color: #a0a0a0; text-align: center; padding: 20px;">
                        위의 위치를 클릭하여 경로에 추가하세요
                    </div>
                </div>
            </div>

            <div class="form-group">
                <label>저장된 경로</label>
                <select class="route-select" id="savedRouteSelect" onchange="loadSelectedRoute()">
                    <option value="">-- 기존 경로 불러오기 --</option>
                </select>
            </div>

            <div class="btn-row">
                <button class="btn btn-secondary" onclick="closeRouteModal()">취소</button>
                <button class="btn btn-secondary" onclick="deleteCurrentRoute()" style="background: #e94560;">삭제</button>
                <button class="btn btn-primary" onclick="saveRoute()">경로 저장</button>
            </div>
        </div>
    </div>

    <!-- Speech/Zone Management Modal -->
    <div class="modal" id="speechModal">
        <div class="modal-content route-modal-content">
            <h2>존 음성 관리</h2>
            <p style="color: #a0a0a0; margin-bottom: 20px;">각 존에 도착하면 설정된 멘트를 읽어줍니다. 포인트는 단순히 "포인트 X에 도착했어요"라고 안내합니다.</p>

            <div class="zone-list" id="zoneList">
                <!-- Zone items will be rendered here -->
            </div>

            <div class="btn-row">
                <button class="btn btn-secondary" onclick="closeSpeechModal()">닫기</button>
                <button class="btn btn-primary" onclick="saveZones()">저장</button>
            </div>
        </div>
    </div>

    <!-- Build Map Modal -->
    <div class="modal" id="buildMapModal">
        <div class="modal-content build-map-modal-content">
            <div class="build-map-header">
                <h2>지도 제작</h2>
                <div class="build-mode-indicator inactive" id="buildModeIndicator">
                    <div class="indicator-dot"></div>
                    <span id="buildModeText">대기 중</span>
                </div>
            </div>

            <div class="estop-warning" id="estopWarning" style="display: none;">
                비상정지 버튼이 해제되어 있습니다. 조종 버튼 사용 가능! (로봇을 밀려면 E-Stop을 누르세요)
            </div>

            <div class="robot-position-display">
                <div class="pos-label">현재 로봇 위치</div>
                <div class="pos-values">
                    <span>X: <span id="buildPosX">0.00</span>m</span>
                    <span>Y: <span id="buildPosY">0.00</span>m</span>
                    <span>θ: <span id="buildPosTheta">0.0</span>°</span>
                </div>
            </div>

            <div class="build-map-layout">
                <div class="build-map-preview" id="buildMapPreview">
                    <canvas id="buildMapCanvas"></canvas>
                </div>

                <div class="build-controls">
                    <!-- Jog Dial -->
                    <div class="jog-dial-container">
                        <h4>로봇 조종</h4>
                        <div class="jog-dial" id="jogDial">
                            <button class="jog-btn rotate-left" data-direction="rotate-left">↺</button>
                            <button class="jog-btn forward" data-direction="forward">▲</button>
                            <button class="jog-btn rotate-right" data-direction="rotate-right">↻</button>
                            <button class="jog-btn left" data-direction="left">◀</button>
                            <button class="jog-btn stop-jog" data-direction="stop">■</button>
                            <button class="jog-btn right" data-direction="right">▶</button>
                            <div></div>
                            <button class="jog-btn backward" data-direction="backward">▼</button>
                            <div></div>
                        </div>
                    </div>

                    <!-- Speed Control -->
                    <div class="speed-control">
                        <label>조종 속도</label>
                        <input type="range" class="speed-slider" id="jogSpeedSlider" min="0.1" max="0.5" step="0.05" value="0.2" oninput="updateJogSpeed(this.value)">
                        <div class="speed-value"><span id="jogSpeedValue">0.2</span> m/s</div>
                    </div>

                    <!-- Waypoint Capture -->
                    <div class="waypoint-capture">
                        <h4>위치 저장</h4>
                        <input type="text" id="capturePointName" placeholder="위치 이름 입력...">
                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; gap: 5px; color: #a0a0a0; font-size: 0.9em;">
                                <input type="checkbox" id="isChargingDock"> 충전 도크
                            </label>
                        </div>
                        <button class="capture-btn" onclick="captureWaypoint()">현재 위치 저장</button>
                    </div>

                    <!-- Captured Points -->
                    <div class="captured-points">
                        <h4>저장된 위치 (<span id="capturedPointsCount">0</span>개)</h4>
                        <div id="capturedPointsList">
                            <div style="color: #a0a0a0; text-align: center; padding: 10px; font-size: 0.9em;">
                                아직 저장된 위치가 없습니다
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="map-actions" style="margin-top: 20px;">
                <button class="btn btn-primary" onclick="startNewMapping()" style="background: #e94560;">새 지도 시작</button>
                <button class="btn btn-secondary" onclick="openSavedMapsModal()">저장된 지도</button>
                <button class="btn btn-reset" onclick="resetBuildMap()">초기화</button>
                <button class="btn btn-save" onclick="saveBuildMap()">AMR에 저장</button>
                <button class="btn btn-secondary" onclick="closeBuildMapModal()">닫기</button>
            </div>
        </div>
    </div>

    <!-- Saved Maps Modal -->
    <div class="modal" id="savedMapsModal">
        <div class="modal-content">
            <h2>저장된 지도 목록</h2>
            <div class="saved-maps-list" id="savedMapsList">
                <div style="color: #a0a0a0; text-align: center; padding: 20px;">
                    저장된 지도가 없습니다
                </div>
            </div>
            <div class="btn-row">
                <button class="btn btn-secondary" onclick="closeSavedMapsModal()">닫기</button>
                <button class="btn btn-primary" onclick="loadSelectedMap()">불러오기</button>
            </div>
        </div>
    </div>

    <button class="settings-btn" onclick="openSettings()">&#9881;</button>

    <script>
        // Configuration
        const API_BASE = '/api';  // Proxy server
        let AMR_IP = '192.168.219.42';
        let voiceEnabled = true;
        let currentWaypoints = [];
        let robotPose = { x: 0, y: 0, theta: 0 };
        let mapBounds = { minX: -1.5, maxX: 0.8, minY: -1, maxY: 1 };
        let lastNavState = null;
        let statusInterval = null;

        // Zone definitions with pre-stored speech text
        // Zones are special locations with long speech, Points just get simple announcements
        const defaultZones = [
            {
                id: 'zone1',
                name: '웰컴 존',
                pointName: '',  // Will be mapped to a waypoint
                speech: '안녕 나는 서희봇이야! 이천 서희도서관 맘대로 에이플러스 놀이터에 온걸을 환영해! 미래에서 가장 중요한 에이아이와 반도체에 대해서 즐겁게 알아보는 시간을 가져볼까?'
            },
            {
                id: 'zone2',
                name: '미디어 존',
                pointName: '',
                speech: '앞으로 우리가 살아갈 미래에 가장 중요한 것이 인공지능과 반도체야! 우리 생활속에서 어떻게 사용되는지 함께 알아보고 우리가 만들어갈 미래에 대해서도 함께 이야기해볼까?'
            },
            {
                id: 'zone3',
                name: '인터렉티브 존',
                pointName: '',
                speech: '인공지능과 반도체가 어떻게 작동되는지 우리 체험놀이를 통해서 알아볼까?'
            },
            {
                id: 'zone4',
                name: '홀로그램 존',
                pointName: '',
                speech: '우와! 다양한 물고기 로봇을 만들고 있네? 이런 로봇에 들어가는 인공지능 반도체는 어떤 모습일까? 반도체가 어떻게 생겼는지 함께 알아볼까? 렛츠고!'
            },
            {
                id: 'zone5',
                name: '미래역량체험 존',
                pointName: '',
                speech: '여기는 마음껏 뛰어놀고 함께 미래역량 체험놀이터야! 놀다보면 나도모르게 미래 창의역량, 협동역량, 비판적사고역량, 의사소통능력이 생기는 곳이지!'
            },
            {
                id: 'zone6',
                name: '메모리 존',
                pointName: '',
                speech: '오늘 체험은 즐거웠니? 헤어지는게 너무 아쉬워서 사진을 찍었어! 우리 소중한 추억을 함께 기억할께! 다음에 보자!'
            }
        ];

        let zones = [];

        // Load zones from localStorage or use defaults
        function loadZones() {
            const saved = localStorage.getItem('docentZones');
            if (saved) {
                zones = JSON.parse(saved);
            } else {
                zones = JSON.parse(JSON.stringify(defaultZones));
            }
        }

        // Save zones to localStorage
        function saveZonesToStorage() {
            localStorage.setItem('docentZones', JSON.stringify(zones));
        }

        // Get speech text for a waypoint (returns null if it's just a point, not a zone)
        function getZoneSpeech(waypointName) {
            const zone = zones.find(z => z.pointName === waypointName);
            if (zone) {
                return { zoneName: zone.name, speech: zone.speech };
            }
            return null;
        }

        // Simple point announcement
        function getPointAnnouncement(pointName) {
            if (pointName === 'chargingdock') {
                return '충전 스테이션에 도착했어요';
            }
            return `${pointName}에 도착했어요`;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            log('시스템 초기화 완료', 'info');
            loadZones();
            loadWaypoints();
            startStatusPolling();
            drawMap();
            checkTTSAvailability();
        });

        // Logging function
        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="time">${time}</span>${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);

            // Keep only last 50 entries
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // API call helper
        async function apiCall(endpoint, method = 'GET', body = null) {
            try {
                const options = {
                    method,
                    headers: { 'Content-Type': 'application/json' }
                };
                if (body) {
                    options.body = JSON.stringify(body);
                }
                const response = await fetch(`${API_BASE}/${endpoint}`, options);
                return await response.json();
            } catch (error) {
                log(`API Error: ${error.message}`, 'error');
                throw error;
            }
        }

        // Load waypoints from AMR
        async function loadWaypoints() {
            try {
                const data = await apiCall('reeman/position');
                currentWaypoints = data.waypoints || [];
                renderWaypointList();
                updateMapMarkers();
                log(`${currentWaypoints.length}개 위치 로드됨`, 'success');
            } catch (error) {
                log('위치 로드 실패', 'error');
            }
        }

        // Render waypoint list
        function renderWaypointList() {
            const list = document.getElementById('waypointList');
            const typeLabels = {
                'charge': '충전',
                'delivery': '배달',
                'normal': '일반'
            };
            list.innerHTML = currentWaypoints.map(wp => {
                // Check if this waypoint is connected to a zone
                const zone = zones.find(z => z.pointName === wp.name);
                const zoneBadge = zone ? `<span class="zone-badge">${zone.name}</span>` : '';

                return `
                <div class="waypoint-item" data-name="${wp.name}">
                    <div>
                        <div class="name">${wp.name}${zoneBadge}</div>
                        <div class="type">${typeLabels[wp.type] || wp.type}</div>
                    </div>
                    <div class="btn-group">
                        <button class="go-btn" onclick="navigateTo('${wp.name}')">이동</button>
                        <button class="del-btn" onclick="deleteWaypoint('${wp.name}')">삭제</button>
                    </div>
                </div>
            `}).join('');
        }

        // Navigate to waypoint
        async function navigateTo(pointName) {
            try {
                log(`${pointName}(으)로 이동 중...`, 'info');
                const result = await apiCall('cmd/nav_name', 'POST', { point: pointName });
                if (result.status === 'success') {
                    log(`${pointName}(으)로 이동 시작`, 'success');
                    highlightWaypoint(pointName);
                } else {
                    log(`이동 실패: ${JSON.stringify(result)}`, 'error');
                }
            } catch (error) {
                log(`이동 오류: ${error.message}`, 'error');
            }
        }

        // Highlight active waypoint
        function highlightWaypoint(name) {
            document.querySelectorAll('.waypoint-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.name === name) {
                    item.classList.add('active');
                }
            });
        }

        // Go home (charging dock)
        async function goHome() {
            const chargePoint = currentWaypoints.find(wp => wp.type === 'charge');
            if (chargePoint) {
                navigateTo(chargePoint.name);
            } else {
                log('충전 도크를 찾을 수 없습니다', 'error');
            }
        }

        // Go to charging dock - uses cmd/charge for automatic docking procedure
        async function goCharge() {
            try {
                log('충전 도킹 시작...', 'info');

                // cmd/charge triggers automatic docking procedure
                // Robot will find the charging dock IR signal and connect
                const result = await apiCall('cmd/charge', 'POST', {});

                if (result.status === 'success' || result.res === 0) {
                    log('충전 도킹 명령 전송됨 - 자동 도킹 중...', 'success');
                    speakSafe('충전 도킹을 시작합니다');
                } else {
                    log(`충전 도킹 실패: ${JSON.stringify(result)}`, 'error');
                    // Fallback to navigating to charge point
                    const chargePoint = currentWaypoints.find(wp => wp.type === 'charge');
                    if (chargePoint) {
                        log('충전 위치로 이동 시도...', 'info');
                        navigateTo(chargePoint.name);
                    } else {
                        log('충전 도크를 찾을 수 없습니다', 'error');
                    }
                }
            } catch (error) {
                log(`충전 오류: ${error.message}`, 'error');
                // Fallback to navigating to charge point
                const chargePoint = currentWaypoints.find(wp => wp.type === 'charge');
                if (chargePoint) {
                    navigateTo(chargePoint.name);
                } else {
                    log('충전 도크를 찾을 수 없습니다', 'error');
                }
            }
        }

        // Delete waypoint
        async function deleteWaypoint(name) {
            if (!confirm(`"${name}" 위치를 삭제하시겠습니까?`)) {
                return;
            }

            try {
                // AMR API expects DELETE with body as array: ["pointName"]
                const response = await fetch(`${API_BASE}/cmd/position`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify([name])
                });
                const result = await response.json();
                if (result.status === 'success') {
                    log(`위치 "${name}" 삭제됨`, 'success');
                    loadWaypoints();
                } else {
                    log(`위치 삭제 실패: ${JSON.stringify(result)}`, 'error');
                }
            } catch (error) {
                log(`삭제 오류: ${error.message}`, 'error');
            }
        }

        // Stop navigation
        async function stopNavigation() {
            try {
                await apiCall('cmd/cancel_goal', 'POST', {});
                // Also send stop command
                await apiCall('cmd/speed', 'POST', { vx: 0, vth: 0 });
                log('긴급 정지 실행', 'success');
            } catch (error) {
                log(`정지 실패: ${error.message}`, 'error');
            }
        }

        // Pause navigation (not directly supported, use stop)
        async function pauseNavigation() {
            try {
                await apiCall('cmd/speed', 'POST', { vx: 0, vth: 0 });
                log('이동 일시정지', 'info');
            } catch (error) {
                log(`일시정지 실패: ${error.message}`, 'error');
            }
        }

        // Resume navigation
        async function resumeNavigation() {
            try {
                await apiCall('cmd/resume_nav', 'POST', {});
                log('이동 재개', 'info');
            } catch (error) {
                log(`재개 실패: ${error.message}`, 'error');
            }
        }

        // Add current location as waypoint
        async function addCurrentLocation() {
            const name = document.getElementById('newWaypointName').value.trim();
            if (!name) {
                log('위치 이름을 입력하세요', 'error');
                return;
            }

            try {
                // Get current position
                const pose = await apiCall('reeman/pose');

                // Create waypoint
                const result = await apiCall('cmd/position', 'POST', {
                    name: name,
                    type: 'delivery',
                    pose: {
                        x: pose.x,
                        y: pose.y,
                        theta: pose.theta
                    }
                });

                if (result.status === 'success') {
                    log(`위치 추가됨: ${name}`, 'success');
                    document.getElementById('newWaypointName').value = '';
                    loadWaypoints();
                } else {
                    log(`위치 추가 실패: ${JSON.stringify(result)}`, 'error');
                }
            } catch (error) {
                log(`위치 추가 오류: ${error.message}`, 'error');
            }
        }

        // Status polling
        function startStatusPolling() {
            statusInterval = setInterval(updateStatus, 1000);
            updateStatus();
        }

        async function updateStatus() {
            try {
                // Get battery and emergency status
                const baseEncode = await apiCall('reeman/base_encode');
                updateBatteryDisplay(baseEncode.battery);
                updateConnectionStatus(true);

                // Check emergency button
                if (baseEncode.emergencyButton === 0) {
                    document.getElementById('robotStatus').textContent = 'E-STOP';
                    document.getElementById('robotStatus').className = 'value danger';
                } else if (baseEncode.chargeFlag === 2) {
                    document.getElementById('robotStatus').textContent = 'Charging';
                    document.getElementById('robotStatus').className = 'value';
                }

                // Get navigation status
                const navStatus = await apiCall('reeman/nav_status');
                updateNavStatus(navStatus);

                // Get current pose
                const pose = await apiCall('reeman/pose');
                robotPose = pose;
                updateRobotPosition();

            } catch (error) {
                updateConnectionStatus(false);
            }
        }

        function updateBatteryDisplay(level) {
            const el = document.getElementById('batteryLevel');
            el.textContent = `${level}%`;
            el.className = 'value';
            if (level < 20) {
                el.className = 'value danger';
            } else if (level < 50) {
                el.className = 'value warning';
            }
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('connectionDot');
            const text = document.getElementById('connectionText');
            if (connected) {
                dot.classList.add('connected');
                text.textContent = '연결됨';
            } else {
                dot.classList.remove('connected');
                text.textContent = '연결 끊김';
            }
        }

        function updateNavStatus(status) {
            const goalEl = document.getElementById('currentGoal');
            const distEl = document.getElementById('distanceToGoal');
            const statusEl = document.getElementById('robotStatus');

            goalEl.textContent = status.goal || '--';
            distEl.textContent = status.dist ? `${status.dist.toFixed(2)}m` : '--';

            // Status interpretation (Korean)
            const stateMap = {
                1: '이동 중',
                3: '도착',
                4: '취소됨',
                6: '대기'
            };

            if (status.res !== undefined) {
                statusEl.textContent = stateMap[status.res] || `상태 ${status.res}`;

                // Check if just arrived at destination
                // Skip if route is running (route handler will manage speech)
                if (status.res === 3 && lastNavState !== 3 && status.goal && !isRouteRunning) {
                    onArrival(status.goal);
                }
            }

            lastNavState = status.res;
        }

        // Called when robot arrives at destination
        function onArrival(goalName) {
            log(`${goalName}에 도착`, 'success');

            if (voiceEnabled) {
                // Check if this waypoint is mapped to a zone
                const zoneInfo = getZoneSpeech(goalName);

                if (zoneInfo) {
                    // This is a zone - speak the full zone speech
                    log(`${zoneInfo.zoneName} 안내 시작`, 'info');
                    speak(zoneInfo.speech);
                    showAnnouncement(zoneInfo.zoneName);
                } else {
                    // This is just a point - simple announcement
                    const announcement = getPointAnnouncement(goalName);
                    speak(announcement);
                    showAnnouncement(announcement);
                }
            }
        }

        // Text-to-speech settings
        let ttsVoice = localStorage.getItem('ttsVoice') || 'ko-KR-Wavenet-A';
        let ttsRate = parseFloat(localStorage.getItem('ttsRate')) || 1.0;
        let ttsPitch = parseFloat(localStorage.getItem('ttsPitch')) || 0.0;
        let ttsEnabled = true;  // Will be set based on API availability
        let currentAudio = null;

        // Check TTS availability on load
        async function checkTTSAvailability() {
            try {
                const response = await fetch('/api/tts/voices');
                const data = await response.json();
                ttsEnabled = data.tts_enabled;
                if (!ttsEnabled) {
                    log('Google TTS 미설정 - 브라우저 TTS 사용', 'info');
                }
            } catch (error) {
                ttsEnabled = false;
                log('TTS 상태 확인 실패 - 브라우저 TTS 사용', 'info');
            }
        }

        // Safe speak that handles autoplay errors gracefully
        async function speakSafe(text) {
            if (!text) return;

            try {
                await speak(text);
            } catch (error) {
                // Autoplay was blocked - log it but don't throw error
                console.log('Audio autoplay blocked, skipping speech:', text.substring(0, 50) + '...');
                log('음성 안내가 차단됨 (브라우저 정책)', 'info');
            }
        }

        // Text-to-speech using Google Cloud TTS
        async function speak(text) {
            if (!text) return;

            // Stop any currently playing audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }

            // Cancel any browser speech
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }

            if (ttsEnabled) {
                try {
                    const response = await fetch('/api/tts', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            text: text,
                            voice: ttsVoice,
                            rate: ttsRate,
                            pitch: ttsPitch
                        })
                    });

                    if (response.ok) {
                        const audioBlob = await response.blob();
                        const audioUrl = URL.createObjectURL(audioBlob);
                        currentAudio = new Audio(audioUrl);

                        // Return a promise that resolves when audio plays or rejects on error
                        return new Promise((resolve, reject) => {
                            currentAudio.onended = () => {
                                URL.revokeObjectURL(audioUrl);
                                currentAudio = null;
                                resolve();
                            };
                            currentAudio.onerror = (e) => {
                                URL.revokeObjectURL(audioUrl);
                                currentAudio = null;
                                reject(e);
                            };
                            currentAudio.play().catch(reject);
                        });
                    } else {
                        const error = await response.json();
                        log(`TTS 오류: ${error.error}`, 'error');
                    }
                } catch (error) {
                    log(`TTS 요청 실패: ${error.message}`, 'error');
                }
            }

            // Fallback to browser speech synthesis
            if ('speechSynthesis' in window) {
                return new Promise((resolve, reject) => {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 0.9;
                    utterance.pitch = 1;
                    utterance.volume = 1;
                    utterance.onend = resolve;
                    utterance.onerror = reject;

                    // Try to find Korean voice
                    const voices = speechSynthesis.getVoices();
                    const koreanVoice = voices.find(v => v.lang.startsWith('ko'));
                    if (koreanVoice) {
                        utterance.voice = koreanVoice;
                    }
                    speechSynthesis.speak(utterance);
                });
            }
        }

        // Show announcement banner
        function showAnnouncement(text) {
            const banner = document.getElementById('announcementBanner');
            banner.textContent = text;
            banner.classList.add('show');
            setTimeout(() => {
                banner.classList.remove('show');
            }, 5000);
        }

        // Map drawing
        function drawMap() {
            const canvas = document.getElementById('mapCanvas');
            const container = document.getElementById('mapContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            const ctx = canvas.getContext('2d');

            // Draw grid
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 1;

            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw center cross
            ctx.strokeStyle = '#0f3460';
            ctx.lineWidth = 2;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            ctx.beginPath();
            ctx.moveTo(centerX - 20, centerY);
            ctx.lineTo(centerX + 20, centerY);
            ctx.moveTo(centerX, centerY - 20);
            ctx.lineTo(centerX, centerY + 20);
            ctx.stroke();
        }

        // Update waypoint markers on map
        function updateMapMarkers() {
            // Remove existing markers
            document.querySelectorAll('.waypoint-marker').forEach(m => m.remove());
            document.querySelectorAll('.waypoint-label').forEach(l => l.remove());

            const container = document.getElementById('mapContainer');

            currentWaypoints.forEach(wp => {
                const pos = worldToScreen(wp.pose.x, wp.pose.y);

                // Create marker
                const marker = document.createElement('div');
                marker.className = `waypoint-marker ${wp.type === 'charge' ? 'charge' : ''}`;
                marker.style.left = `${pos.x}px`;
                marker.style.top = `${pos.y}px`;
                marker.onclick = () => navigateTo(wp.name);

                // Create label
                const label = document.createElement('div');
                label.className = 'waypoint-label';
                label.textContent = wp.name;
                label.style.left = `${pos.x}px`;
                label.style.top = `${pos.y}px`;

                container.appendChild(marker);
                container.appendChild(label);
            });
        }

        // Update robot position on map
        function updateRobotPosition() {
            const marker = document.getElementById('robotMarker');
            const pos = worldToScreen(robotPose.x, robotPose.y);
            marker.style.left = `${pos.x}px`;
            marker.style.top = `${pos.y}px`;
            marker.style.transform = `translate(-50%, -50%) rotate(${(robotPose.theta * 180 / Math.PI) - 90}deg)`;
        }

        // Convert world coordinates to screen coordinates
        function worldToScreen(x, y) {
            const container = document.getElementById('mapContainer');
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Map bounds (adjust based on your map)
            const rangeX = mapBounds.maxX - mapBounds.minX;
            const rangeY = mapBounds.maxY - mapBounds.minY;

            const screenX = ((x - mapBounds.minX) / rangeX) * width;
            const screenY = height - ((y - mapBounds.minY) / rangeY) * height;

            return { x: screenX, y: screenY };
        }

        // Settings
        function openSettings() {
            // Load current TTS settings into form
            document.getElementById('ttsVoiceSelect').value = ttsVoice;
            document.getElementById('ttsRateInput').value = ttsRate;
            document.getElementById('ttsRateValue').textContent = ttsRate.toFixed(1);

            // Add rate slider listener
            document.getElementById('ttsRateInput').oninput = function() {
                document.getElementById('ttsRateValue').textContent = this.value;
            };

            document.getElementById('settingsModal').classList.add('show');
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('show');
        }

        function saveSettings() {
            AMR_IP = document.getElementById('amrIpInput').value;
            voiceEnabled = document.getElementById('voiceEnabledSelect').value === 'true';

            // Save TTS settings
            ttsVoice = document.getElementById('ttsVoiceSelect').value;
            ttsRate = parseFloat(document.getElementById('ttsRateInput').value);

            localStorage.setItem('ttsVoice', ttsVoice);
            localStorage.setItem('ttsRate', ttsRate.toString());

            const speed = document.getElementById('navSpeedSelect').value;
            apiCall('cmd/max_speed', 'POST', { speed: parseFloat(speed) })
                .then(() => log(`속도 설정: ${speed} m/s`, 'success'))
                .catch(err => log(`속도 설정 실패: ${err.message}`, 'error'));

            closeSettings();
            log('설정 저장됨', 'success');
        }

        // Test TTS from settings
        async function testTTS() {
            const voice = document.getElementById('ttsVoiceSelect').value;
            const rate = parseFloat(document.getElementById('ttsRateInput').value);

            // Stop any currently playing audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }

            const testText = '안녕하세요, 서희도서관 도슨트 로봇입니다. 음성 테스트입니다.';

            if (ttsEnabled) {
                try {
                    const response = await fetch('/api/tts', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            text: testText,
                            voice: voice,
                            rate: rate,
                            pitch: ttsPitch
                        })
                    });

                    if (response.ok) {
                        const audioBlob = await response.blob();
                        const audioUrl = URL.createObjectURL(audioBlob);
                        currentAudio = new Audio(audioUrl);
                        currentAudio.play();
                        currentAudio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                            currentAudio = null;
                        };
                        log('TTS 테스트 재생 (Google Cloud)', 'info');
                        return;
                    }
                } catch (error) {
                    log(`TTS 테스트 실패: ${error.message}`, 'error');
                }
            }

            // Fallback to browser TTS
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(testText);
                utterance.rate = rate;
                const voices = speechSynthesis.getVoices();
                const koreanVoice = voices.find(v => v.lang.startsWith('ko'));
                if (koreanVoice) {
                    utterance.voice = koreanVoice;
                }
                speechSynthesis.speak(utterance);
                log('TTS 테스트 재생 (브라우저)', 'info');
            }
        }

        // ========== DOCKING SETTINGS ==========

        async function loadDockingSettings() {
            try {
                log('도킹 설정 불러오는 중...', 'info');

                // Fetch current docking distance
                const distResponse = await fetch(`${API_BASE}/reeman/agv_docking_dis`);
                if (distResponse.ok) {
                    const distData = await distResponse.json();
                    const distance = parseFloat(distData.distance || distData.data?.distance || -0.7);
                    document.getElementById('dockingDistanceInput').value = distance;
                    log(`도킹 거리: ${distance}m`, 'info');
                }

                // Fetch current docking direction
                const dirResponse = await fetch(`${API_BASE}/reeman/agv_docking_direction`);
                if (dirResponse.ok) {
                    const dirData = await dirResponse.json();
                    const direction = dirData.direction || dirData.data?.direction || '1';
                    document.getElementById('dockingDirectionSelect').value = direction;
                    log(`도킹 방향: ${direction === '1' || direction === 1 ? '후진' : '전진'}`, 'info');
                }

                log('도킹 설정 불러오기 완료', 'success');
            } catch (error) {
                log(`도킹 설정 불러오기 실패: ${error.message}`, 'error');
            }
        }

        async function saveDockingSettings() {
            try {
                const distance = parseFloat(document.getElementById('dockingDistanceInput').value);
                const direction = document.getElementById('dockingDirectionSelect').value;

                log('도킹 설정 저장 중...', 'info');

                // Save docking distance
                const distResponse = await fetch(`${API_BASE}/cmd/agv_docking_dis`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ distance: distance })
                });

                if (!distResponse.ok) {
                    throw new Error(`거리 설정 실패: ${distResponse.status}`);
                }

                // Save docking direction
                const dirResponse = await fetch(`${API_BASE}/cmd/agv_docking_direction`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ direction: parseInt(direction) })
                });

                if (!dirResponse.ok) {
                    throw new Error(`방향 설정 실패: ${dirResponse.status}`);
                }

                log(`도킹 설정 저장 완료 - 거리: ${distance}m, 방향: ${direction === '1' ? '후진' : '전진'}`, 'success');
                alert('도킹 설정이 저장되었습니다.');
            } catch (error) {
                log(`도킹 설정 저장 실패: ${error.message}`, 'error');
                alert(`도킹 설정 저장 실패: ${error.message}`);
            }
        }

        // Window resize handler
        window.addEventListener('resize', () => {
            drawMap();
            updateMapMarkers();
            updateRobotPosition();
        });

        // ========== ROUTE MANAGEMENT ==========

        // Route state
        let savedRoutes = {};
        let currentRoutePoints = [];
        let isRouteRunning = false;
        let currentRouteIndex = 0;
        let currentRoute = null;
        let stayTimeRemaining = 0;
        let stayTimeInterval = null;
        let routeCheckInterval = null;

        // Initialize routes on load
        document.addEventListener('DOMContentLoaded', () => {
            loadSavedRoutes();
        });

        // Load saved routes from localStorage
        function loadSavedRoutes() {
            const saved = localStorage.getItem('docentRoutes');
            if (saved) {
                savedRoutes = JSON.parse(saved);
            }
            updateRouteSelects();
        }

        // Save routes to localStorage
        function saveRoutesToStorage() {
            localStorage.setItem('docentRoutes', JSON.stringify(savedRoutes));
            updateRouteSelects();
        }

        // Update route select dropdowns
        function updateRouteSelects() {
            const routeNames = Object.keys(savedRoutes);

            // Main route select
            const mainSelect = document.getElementById('routeSelect');
            mainSelect.innerHTML = '<option value="">-- 실행할 경로 선택 --</option>' +
                routeNames.map(name => `<option value="${name}">${name}</option>`).join('');

            // Modal route select
            const modalSelect = document.getElementById('savedRouteSelect');
            modalSelect.innerHTML = '<option value="">-- 기존 경로 불러오기 --</option>' +
                routeNames.map(name => `<option value="${name}">${name}</option>`).join('');
        }

        // Open route creation modal
        function openRouteModal() {
            currentRoutePoints = [];
            document.getElementById('routeNameInput').value = '';
            document.getElementById('savedRouteSelect').value = '';
            renderAvailablePoints();
            renderRoutePoints();
            document.getElementById('routeModal').classList.add('show');
        }

        // Close route modal
        function closeRouteModal() {
            document.getElementById('routeModal').classList.remove('show');
        }

        // Render available waypoints
        function renderAvailablePoints() {
            const container = document.getElementById('availablePoints');
            const pointsInRoute = currentRoutePoints.map(p => p.name);

            container.innerHTML = currentWaypoints.map(wp => {
                const inRoute = pointsInRoute.includes(wp.name);
                return `<button class="available-point-btn ${inRoute ? 'in-route' : ''}"
                    onclick="addPointToRoute('${wp.name}')">${wp.name}</button>`;
            }).join('');
        }

        // Add point to route
        function addPointToRoute(name) {
            currentRoutePoints.push({
                name: name,
                stayTime: 10  // Default 10 seconds
            });
            renderAvailablePoints();
            renderRoutePoints();
        }

        // Render route points list
        function renderRoutePoints() {
            const container = document.getElementById('routePointList');

            if (currentRoutePoints.length === 0) {
                container.innerHTML = `
                    <div style="color: #a0a0a0; text-align: center; padding: 20px;">
                        위의 위치를 클릭하여 경로에 추가하세요
                    </div>`;
                return;
            }

            container.innerHTML = currentRoutePoints.map((point, index) => `
                <div class="route-point-item" draggable="true" data-index="${index}">
                    <div class="point-info">
                        <div class="point-order">${index + 1}</div>
                        <div class="point-name">${point.name}</div>
                    </div>
                    <div class="point-controls">
                        <span class="stay-time-label">대기:</span>
                        <input type="number" class="stay-time-input" value="${point.stayTime}"
                            min="0" max="300" onchange="updateStayTime(${index}, this.value)">
                        <span class="stay-time-label">초</span>
                        <div class="move-btns">
                            <button class="move-btn" onclick="movePointUp(${index})">&#9650;</button>
                            <button class="move-btn" onclick="movePointDown(${index})">&#9660;</button>
                        </div>
                        <button class="remove-btn" onclick="removePoint(${index})">&#10005;</button>
                    </div>
                </div>
            `).join('');

            // Add drag and drop listeners
            setupDragAndDrop();
        }

        // Update stay time for a point
        function updateStayTime(index, value) {
            currentRoutePoints[index].stayTime = parseInt(value) || 0;
        }

        // Move point up in order
        function movePointUp(index) {
            if (index > 0) {
                const temp = currentRoutePoints[index];
                currentRoutePoints[index] = currentRoutePoints[index - 1];
                currentRoutePoints[index - 1] = temp;
                renderRoutePoints();
            }
        }

        // Move point down in order
        function movePointDown(index) {
            if (index < currentRoutePoints.length - 1) {
                const temp = currentRoutePoints[index];
                currentRoutePoints[index] = currentRoutePoints[index + 1];
                currentRoutePoints[index + 1] = temp;
                renderRoutePoints();
            }
        }

        // Remove point from route
        function removePoint(index) {
            currentRoutePoints.splice(index, 1);
            renderAvailablePoints();
            renderRoutePoints();
        }

        // Setup drag and drop for reordering
        function setupDragAndDrop() {
            const items = document.querySelectorAll('.route-point-item');
            let draggedItem = null;

            items.forEach(item => {
                item.addEventListener('dragstart', function(e) {
                    draggedItem = this;
                    this.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                    draggedItem = null;
                });

                item.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });

                item.addEventListener('drop', function(e) {
                    e.preventDefault();
                    if (draggedItem !== this) {
                        const fromIndex = parseInt(draggedItem.dataset.index);
                        const toIndex = parseInt(this.dataset.index);

                        const movedItem = currentRoutePoints.splice(fromIndex, 1)[0];
                        currentRoutePoints.splice(toIndex, 0, movedItem);
                        renderRoutePoints();
                    }
                });
            });
        }

        // Save route
        function saveRoute() {
            const name = document.getElementById('routeNameInput').value.trim();

            if (!name) {
                log('경로 이름을 입력하세요', 'error');
                return;
            }

            if (currentRoutePoints.length === 0) {
                log('경로에 최소 하나의 위치를 추가하세요', 'error');
                return;
            }

            savedRoutes[name] = {
                name: name,
                points: [...currentRoutePoints],
                createdAt: new Date().toISOString()
            };

            saveRoutesToStorage();
            log(`경로 "${name}" 저장됨 (${currentRoutePoints.length}개 위치)`, 'success');
            closeRouteModal();
        }

        // Load selected route into editor
        function loadSelectedRoute() {
            const name = document.getElementById('savedRouteSelect').value;
            if (!name || !savedRoutes[name]) return;

            const route = savedRoutes[name];
            document.getElementById('routeNameInput').value = route.name;
            currentRoutePoints = [...route.points];
            renderAvailablePoints();
            renderRoutePoints();
            log(`경로 "${name}" 불러옴`, 'info');
        }

        // Delete current route
        function deleteCurrentRoute() {
            const name = document.getElementById('routeNameInput').value.trim();

            if (!name || !savedRoutes[name]) {
                log('삭제할 경로가 선택되지 않았습니다', 'error');
                return;
            }

            if (confirm(`"${name}" 경로를 삭제하시겠습니까?`)) {
                delete savedRoutes[name];
                saveRoutesToStorage();
                currentRoutePoints = [];
                document.getElementById('routeNameInput').value = '';
                document.getElementById('savedRouteSelect').value = '';
                renderRoutePoints();
                log(`경로 "${name}" 삭제됨`, 'success');
            }
        }

        // Handle route select change on main panel
        function onRouteSelect() {
            const name = document.getElementById('routeSelect').value;
            if (name) {
                log(`경로 "${name}" 선택됨`, 'info');
            }
        }

        // Start selected route
        function startSelectedRoute() {
            const name = document.getElementById('routeSelect').value;

            if (!name || !savedRoutes[name]) {
                log('먼저 경로를 선택하세요', 'error');
                return;
            }

            if (isRouteRunning) {
                log('이미 경로가 실행 중입니다', 'error');
                return;
            }

            currentRoute = savedRoutes[name];
            currentRouteIndex = 0;
            isRouteRunning = true;

            // Show route status
            document.getElementById('routeStatus').classList.add('active');
            document.getElementById('stopRouteBtn').classList.add('active');

            log(`경로 "${name}" 시작 (${currentRoute.points.length}개 위치)`, 'success');

            // Start the route
            navigateToNextPoint();
        }

        // Navigate to next point in route
        async function navigateToNextPoint() {
            if (!isRouteRunning || currentRouteIndex >= currentRoute.points.length) {
                finishRoute();
                return;
            }

            const point = currentRoute.points[currentRouteIndex];

            // Update status display
            updateRouteStatusDisplay();

            log(`경로: ${point.name}(으)로 이동 중 (${currentRouteIndex + 1}/${currentRoute.points.length})`, 'info');

            try {
                const result = await apiCall('cmd/nav_name', 'POST', { point: point.name });
                if (result.status === 'success') {
                    highlightWaypoint(point.name);
                    // Start checking for arrival
                    startRouteArrivalCheck(point);
                } else {
                    log(`경로: ${point.name} 이동 실패`, 'error');
                    // Try next point anyway
                    currentRouteIndex++;
                    setTimeout(navigateToNextPoint, 1000);
                }
            } catch (error) {
                log(`경로 이동 오류: ${error.message}`, 'error');
                currentRouteIndex++;
                setTimeout(navigateToNextPoint, 1000);
            }
        }

        // Check for arrival at current route point
        function startRouteArrivalCheck(point) {
            if (routeCheckInterval) {
                clearInterval(routeCheckInterval);
            }

            routeCheckInterval = setInterval(async () => {
                try {
                    const status = await apiCall('reeman/nav_status');

                    if (status.res === 3) {  // Arrived
                        clearInterval(routeCheckInterval);
                        routeCheckInterval = null;

                        log(`경로: ${point.name}에 도착`, 'success');

                        if (voiceEnabled) {
                            // Check if this waypoint is mapped to a zone
                            const zoneInfo = getZoneSpeech(point.name);

                            if (zoneInfo) {
                                // This is a zone - speak the full zone speech
                                log(`${zoneInfo.zoneName} 안내 시작`, 'info');
                                speak(zoneInfo.speech);
                                showAnnouncement(zoneInfo.zoneName);
                            } else {
                                // This is just a point - simple announcement
                                const announcement = getPointAnnouncement(point.name);
                                speak(announcement);
                                showAnnouncement(announcement);
                            }
                        }

                        // Start stay time countdown
                        startStayTimer(point.stayTime);
                    } else if (status.res === 4) {  // Cancelled
                        clearInterval(routeCheckInterval);
                        routeCheckInterval = null;
                        log(`경로: 이동 취소됨`, 'info');
                        // Route will be stopped by stopRoute()
                    }
                } catch (error) {
                    // Continue checking
                }
            }, 1000);
        }

        // Start stay timer at current point
        function startStayTimer(seconds) {
            stayTimeRemaining = seconds;

            if (stayTimeInterval) {
                clearInterval(stayTimeInterval);
            }

            if (seconds <= 0) {
                // No stay time, move to next point immediately
                currentRouteIndex++;
                navigateToNextPoint();
                return;
            }

            document.getElementById('routeStayTime').textContent = `${stayTimeRemaining}s`;

            stayTimeInterval = setInterval(() => {
                stayTimeRemaining--;
                document.getElementById('routeStayTime').textContent = `${stayTimeRemaining}s`;

                if (stayTimeRemaining <= 0) {
                    clearInterval(stayTimeInterval);
                    stayTimeInterval = null;

                    // Move to next point
                    currentRouteIndex++;
                    navigateToNextPoint();
                }
            }, 1000);
        }

        // Update route status display
        function updateRouteStatusDisplay() {
            if (!currentRoute) return;

            const point = currentRoute.points[currentRouteIndex];
            document.getElementById('routeCurrentPoint').textContent = point ? point.name : '--';
            document.getElementById('routeProgress').textContent =
                `${currentRouteIndex + 1} / ${currentRoute.points.length}`;

            const progress = ((currentRouteIndex) / currentRoute.points.length) * 100;
            document.getElementById('routeProgressBar').style.width = `${progress}%`;
        }

        // Finish route
        function finishRoute() {
            isRouteRunning = false;
            currentRoute = null;
            currentRouteIndex = 0;

            if (stayTimeInterval) {
                clearInterval(stayTimeInterval);
                stayTimeInterval = null;
            }

            if (routeCheckInterval) {
                clearInterval(routeCheckInterval);
                routeCheckInterval = null;
            }

            document.getElementById('routeStatus').classList.remove('active');
            document.getElementById('stopRouteBtn').classList.remove('active');
            document.getElementById('routeProgressBar').style.width = '100%';
            document.getElementById('routeStayTime').textContent = '--';

            log('경로 완료!', 'success');

            if (voiceEnabled) {
                speak('경로 안내가 완료되었습니다. 대기 상태로 전환합니다.');
                showAnnouncement('경로 완료!');
            }
        }

        // Stop running route
        async function stopRoute() {
            if (!isRouteRunning) return;

            log('경로 중지 중...', 'info');

            // Cancel current navigation
            try {
                await apiCall('cmd/cancel_goal', 'POST', {});
            } catch (error) {
                // Ignore
            }

            isRouteRunning = false;
            currentRoute = null;
            currentRouteIndex = 0;

            if (stayTimeInterval) {
                clearInterval(stayTimeInterval);
                stayTimeInterval = null;
            }

            if (routeCheckInterval) {
                clearInterval(routeCheckInterval);
                routeCheckInterval = null;
            }

            document.getElementById('routeStatus').classList.remove('active');
            document.getElementById('stopRouteBtn').classList.remove('active');
            document.getElementById('routeStayTime').textContent = '--';

            log('경로 중지됨', 'success');
        }

        // ========== ZONE/SPEECH MANAGEMENT ==========

        // Open speech modal
        function openSpeechModal() {
            renderZoneList();
            document.getElementById('speechModal').classList.add('show');
        }

        // Close speech modal
        function closeSpeechModal() {
            document.getElementById('speechModal').classList.remove('show');
        }

        // Render zone list in modal
        function renderZoneList() {
            const container = document.getElementById('zoneList');

            container.innerHTML = zones.map((zone, index) => `
                <div class="zone-item" data-zone-id="${zone.id}">
                    <div class="zone-header">
                        <span class="zone-name">${index + 1}. ${zone.name}</span>
                        <span class="zone-point">${zone.pointName ? `연결됨: ${zone.pointName}` : '포인트 미연결'}</span>
                    </div>
                    <textarea class="zone-speech"
                        id="speech-${zone.id}"
                        placeholder="이 존에서 할 멘트를 입력하세요...">${zone.speech}</textarea>
                    <div class="zone-controls">
                        <select id="point-${zone.id}" onchange="updateZonePoint('${zone.id}', this.value)">
                            <option value="">-- 포인트 선택 --</option>
                            ${currentWaypoints.map(wp =>
                                `<option value="${wp.name}" ${zone.pointName === wp.name ? 'selected' : ''}>${wp.name} (${wp.type})</option>`
                            ).join('')}
                        </select>
                        <button class="test-btn" onclick="testZoneSpeech('${zone.id}')">테스트</button>
                    </div>
                </div>
            `).join('');
        }

        // Update zone point mapping
        function updateZonePoint(zoneId, pointName) {
            const zone = zones.find(z => z.id === zoneId);
            if (zone) {
                // Clear this point from other zones first
                zones.forEach(z => {
                    if (z.pointName === pointName && z.id !== zoneId) {
                        z.pointName = '';
                    }
                });
                zone.pointName = pointName;
                renderZoneList();  // Re-render to update other dropdowns
            }
        }

        // Test zone speech
        function testZoneSpeech(zoneId) {
            const textarea = document.getElementById(`speech-${zoneId}`);
            const text = textarea.value.trim();
            if (text) {
                speak(text);
                log(`테스트 재생: ${zones.find(z => z.id === zoneId)?.name}`, 'info');
            } else {
                log('멘트를 입력하세요', 'error');
            }
        }

        // Save zones
        function saveZones() {
            // Update speech text from textareas
            zones.forEach(zone => {
                const textarea = document.getElementById(`speech-${zone.id}`);
                if (textarea) {
                    zone.speech = textarea.value.trim();
                }
            });

            saveZonesToStorage();
            log('존 설정이 저장되었습니다', 'success');
            closeSpeechModal();
        }

        // ========== BUILD MAP MODE ==========

        // Build map state
        let isBuildMapMode = false;
        let capturedPoints = [];
        let jogSpeed = 0.2;
        let jogInterval = null;
        let buildMapInterval = null;
        let savedMaps = {};
        let selectedMapName = null;
        let robotPath = [];  // Track robot path for visualization
        let lastBuildPose = null;  // Track last pose for path recording
        let buildMapBounds = { minX: -2, maxX: 2, minY: -2, maxY: 2 };  // Dynamic map bounds
        let slamMapImage = null;  // SLAM map image from AMR
        let slamMapInfo = null;   // SLAM map metadata (resolution, origin, etc.)

        // Initialize build map on load
        document.addEventListener('DOMContentLoaded', () => {
            loadSavedMaps();
        });

        // Open Build Map Modal
        function openBuildMapModal() {
            // Show the modal
            document.getElementById('buildMapModal').classList.add('show');

            // Reset state
            capturedPoints = [];
            robotPath = [];
            lastBuildPose = null;  // Reset last pose tracking
            buildMapBounds = { minX: -2, maxX: 2, minY: -2, maxY: 2 };  // Reset bounds
            renderCapturedPoints();

            // Initialize build map canvas and jog dial
            setTimeout(() => {
                initBuildMapCanvas();
                initJogDial();
                // Fetch initial SLAM map
                fetchSlamMap();
            }, 100);

            // Speak instruction - use safe speak that handles autoplay errors
            const instruction = '지금부터 지도를 제작합니다. 로봇을 직접 밀어서 이동하려면 비상정지 버튼을 누르세요. 조종 버튼으로 이동하려면 비상정지 버튼을 해제하세요.';
            speakSafe(instruction);
            showAnnouncement('지도 제작 모드');

            log('지도 제작 모드 시작', 'info');

            // Check E-Stop status
            checkEStopStatus();

            // Start build map polling
            startBuildMapPolling();
        }

        // Close Build Map Modal
        function closeBuildMapModal() {
            // Stop any jogging
            stopJog();

            // Stop polling
            stopBuildMapPolling();

            // Hide modal
            document.getElementById('buildMapModal').classList.remove('show');

            isBuildMapMode = false;
            updateBuildModeIndicator(false);

            log('지도 제작 모드 종료', 'info');

            // Refresh main waypoint list
            loadWaypoints();
        }

        // Check E-Stop status
        async function checkEStopStatus() {
            try {
                const baseEncode = await apiCall('reeman/base_encode');
                // emergencyButton: 0 = pressed (engaged), 1 = released (disengaged)
                const estopPressed = baseEncode.emergencyButton === 0;

                updateBuildModeIndicator(estopPressed);
                isBuildMapMode = true;  // Always in build mode when modal is open
            } catch (error) {
                log('E-Stop 상태 확인 실패', 'error');
            }
        }

        // Update build mode indicator
        function updateBuildModeIndicator(estopPressed) {
            const indicator = document.getElementById('buildModeIndicator');
            const text = document.getElementById('buildModeText');
            const warning = document.getElementById('estopWarning');

            if (estopPressed) {
                // E-Stop pressed = can push robot manually
                indicator.classList.remove('inactive');
                text.textContent = '수동 모드 (밀기)';
                warning.style.display = 'none';
            } else {
                // E-Stop released = can use jog buttons
                indicator.classList.remove('inactive');
                text.textContent = '조종 모드 (버튼)';
                warning.style.display = 'block';
            }
        }

        // Start build map polling
        function startBuildMapPolling() {
            if (buildMapInterval) {
                clearInterval(buildMapInterval);
            }

            buildMapInterval = setInterval(async () => {
                await updateBuildMapStatus();
            }, 200);  // Update faster for smoother visualization
        }

        // Stop build map polling
        function stopBuildMapPolling() {
            if (buildMapInterval) {
                clearInterval(buildMapInterval);
                buildMapInterval = null;
            }
        }

        // Fetch SLAM map from AMR
        async function fetchSlamMap() {
            try {
                const mapData = await apiCall('reeman/map');

                if (mapData && mapData.image_url) {
                    // Store map metadata
                    slamMapInfo = {
                        width: mapData.width,
                        height: mapData.height,
                        resolution: mapData.resolution,
                        originX: mapData.origin_x,
                        originY: mapData.origin_y
                    };

                    // Load the map image
                    const img = new Image();
                    img.onload = () => {
                        slamMapImage = img;
                        console.log('SLAM map loaded:', slamMapInfo);
                    };
                    img.onerror = () => {
                        console.log('Failed to load SLAM map image');
                    };
                    img.src = mapData.image_url;
                }
            } catch (error) {
                console.log('Failed to fetch SLAM map:', error);
            }
        }

        // Update build map status
        let slamMapUpdateCounter = 0;
        async function updateBuildMapStatus() {
            try {
                // Get current pose
                const pose = await apiCall('reeman/pose');

                // Validate pose data
                if (typeof pose.x !== 'number' || typeof pose.y !== 'number' ||
                    isNaN(pose.x) || isNaN(pose.y)) {
                    console.log('Invalid pose data:', pose);
                    return;
                }

                // Update position display
                document.getElementById('buildPosX').textContent = pose.x.toFixed(2);
                document.getElementById('buildPosY').textContent = pose.y.toFixed(2);
                document.getElementById('buildPosTheta').textContent = (pose.theta * 180 / Math.PI).toFixed(1);

                // Track robot path - only add point if robot moved significantly (> 2cm)
                const minDistance = 0.02;  // 2cm threshold
                let shouldAddPoint = false;

                if (lastBuildPose === null) {
                    // First point
                    shouldAddPoint = true;
                } else {
                    const dx = pose.x - lastBuildPose.x;
                    const dy = pose.y - lastBuildPose.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance >= minDistance) {
                        shouldAddPoint = true;
                    }
                }

                if (shouldAddPoint) {
                    robotPath.push({ x: pose.x, y: pose.y });
                    lastBuildPose = { x: pose.x, y: pose.y };

                    // Update dynamic bounds
                    buildMapBounds.minX = Math.min(buildMapBounds.minX, pose.x - 0.5);
                    buildMapBounds.maxX = Math.max(buildMapBounds.maxX, pose.x + 0.5);
                    buildMapBounds.minY = Math.min(buildMapBounds.minY, pose.y - 0.5);
                    buildMapBounds.maxY = Math.max(buildMapBounds.maxY, pose.y + 0.5);

                    // Limit path length
                    if (robotPath.length > 2000) {
                        robotPath.shift();
                    }

                    // Log first few points for debugging
                    if (robotPath.length <= 5) {
                        log(`경로 포인트 추가: (${pose.x.toFixed(2)}, ${pose.y.toFixed(2)})`, 'info');
                    }
                }

                // Fetch SLAM map periodically (every ~2 seconds = every 10 polls at 200ms)
                slamMapUpdateCounter++;
                if (slamMapUpdateCounter >= 10) {
                    slamMapUpdateCounter = 0;
                    fetchSlamMap();
                }

                // Update map visualization
                drawBuildMap(pose);

                // Check E-Stop status periodically (less frequently)
                if (Math.random() < 0.1) {  // Only check 10% of the time
                    const baseEncode = await apiCall('reeman/base_encode');
                    // emergencyButton: 0 = pressed (engaged), 1 = released (disengaged)
                    const estopPressed = baseEncode.emergencyButton === 0;
                    updateBuildModeIndicator(estopPressed);
                }
            } catch (error) {
                console.log('Build map status error:', error);
                // Ignore errors during polling
            }
        }

        // Initialize build map canvas
        function initBuildMapCanvas() {
            const canvas = document.getElementById('buildMapCanvas');
            const container = document.getElementById('buildMapPreview');

            if (!canvas || !container) {
                console.log('Canvas or container not found');
                return;
            }

            // Set canvas size
            const width = container.clientWidth || 400;
            const height = container.clientHeight || 400;

            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            console.log('Canvas initialized:', width, 'x', height);
            log(`캔버스 초기화: ${width}x${height}`, 'info');

            drawBuildMap({ x: 0, y: 0, theta: 0 });
        }

        // Draw build map
        function drawBuildMap(currentPose) {
            const canvas = document.getElementById('buildMapCanvas');
            if (!canvas) {
                console.log('drawBuildMap: canvas not found');
                return;
            }

            const ctx = canvas.getContext('2d');
            if (!ctx) {
                console.log('drawBuildMap: context not found');
                return;
            }

            // Ensure canvas size matches container
            const container = document.getElementById('buildMapPreview');
            if (!container) return;

            const containerWidth = container.clientWidth || 400;
            const containerHeight = container.clientHeight || 400;

            if (canvas.width !== containerWidth || canvas.height !== containerHeight) {
                canvas.width = containerWidth;
                canvas.height = containerHeight;
            }

            // Clear canvas
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate bounds - use SLAM map bounds if available
            let minX, maxX, minY, maxY;

            if (slamMapInfo) {
                // Use SLAM map bounds
                minX = slamMapInfo.originX;
                maxX = slamMapInfo.originX + slamMapInfo.width * slamMapInfo.resolution;
                minY = slamMapInfo.originY;
                maxY = slamMapInfo.originY + slamMapInfo.height * slamMapInfo.resolution;
            } else {
                // Use dynamic bounds
                minX = buildMapBounds.minX;
                maxX = buildMapBounds.maxX;
                minY = buildMapBounds.minY;
                maxY = buildMapBounds.maxY;
            }

            // Expand bounds to include current position
            if (currentPose) {
                minX = Math.min(minX, currentPose.x - 0.5);
                maxX = Math.max(maxX, currentPose.x + 0.5);
                minY = Math.min(minY, currentPose.y - 0.5);
                maxY = Math.max(maxY, currentPose.y + 0.5);
            }

            // Include captured points in bounds
            capturedPoints.forEach(p => {
                minX = Math.min(minX, p.pose.x - 0.5);
                maxX = Math.max(maxX, p.pose.x + 0.5);
                minY = Math.min(minY, p.pose.y - 0.5);
                maxY = Math.max(maxY, p.pose.y + 0.5);
            });

            const rangeX = Math.max(maxX - minX, 1);
            const rangeY = Math.max(maxY - minY, 1);
            const scale = Math.min(canvas.width / rangeX, canvas.height / rangeY) * 0.9;
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const offsetX = canvas.width / 2;
            const offsetY = canvas.height / 2;

            function toScreen(x, y) {
                return {
                    x: offsetX + (x - centerX) * scale,
                    y: offsetY - (y - centerY) * scale
                };
            }

            // Draw SLAM map if available
            if (slamMapImage && slamMapInfo) {
                ctx.save();

                // Calculate where the SLAM map should be drawn
                const mapOriginScreen = toScreen(slamMapInfo.originX, slamMapInfo.originY + slamMapInfo.height * slamMapInfo.resolution);
                const mapWidth = slamMapInfo.width * slamMapInfo.resolution * scale;
                const mapHeight = slamMapInfo.height * slamMapInfo.resolution * scale;

                // Draw the SLAM map image
                ctx.globalAlpha = 0.8;
                ctx.drawImage(slamMapImage, mapOriginScreen.x, mapOriginScreen.y, mapWidth, mapHeight);
                ctx.globalAlpha = 1.0;

                ctx.restore();
            } else {
                // Draw grid if no SLAM map
                ctx.strokeStyle = '#1a1a2e';
                ctx.lineWidth = 1;
                for (let x = Math.floor(minX); x <= Math.ceil(maxX); x++) {
                    const p1 = toScreen(x, minY);
                    const p2 = toScreen(x, maxY);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
                for (let y = Math.floor(minY); y <= Math.ceil(maxY); y++) {
                    const p1 = toScreen(minX, y);
                    const p2 = toScreen(maxX, y);
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }

            // Draw origin cross
            ctx.strokeStyle = '#0f3460';
            ctx.lineWidth = 2;
            const origin = toScreen(0, 0);
            ctx.beginPath();
            ctx.moveTo(origin.x - 15, origin.y);
            ctx.lineTo(origin.x + 15, origin.y);
            ctx.moveTo(origin.x, origin.y - 15);
            ctx.lineTo(origin.x, origin.y + 15);
            ctx.stroke();

            // Draw robot path
            if (robotPath.length > 0) {
                // Draw thicker, more visible path
                ctx.strokeStyle = '#16c784';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                const start = toScreen(robotPath[0].x, robotPath[0].y);
                ctx.moveTo(start.x, start.y);
                for (let i = 1; i < robotPath.length; i++) {
                    const p = toScreen(robotPath[i].x, robotPath[i].y);
                    ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();

                // Draw start point marker
                ctx.fillStyle = '#ffc107';
                ctx.beginPath();
                ctx.arc(start.x, start.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw path point count on canvas
            ctx.fillStyle = '#a0a0a0';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`경로 포인트: ${robotPath.length}`, 10, 20);

            // Draw captured points
            capturedPoints.forEach((point, index) => {
                const pos = toScreen(point.pose.x, point.pose.y);

                // Draw marker
                ctx.fillStyle = '#4ecca3';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
                ctx.fill();

                // Draw border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw label
                ctx.fillStyle = '#fff';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(point.name, pos.x, pos.y - 15);
            });

            // Draw current robot position
            if (currentPose && typeof currentPose.x === 'number' && typeof currentPose.y === 'number') {
                const robotPos = toScreen(currentPose.x, currentPose.y);

                // Robot body
                ctx.save();
                ctx.translate(robotPos.x, robotPos.y);
                ctx.rotate(-currentPose.theta + Math.PI / 2);

                // Draw robot circle (background)
                ctx.fillStyle = 'rgba(233, 69, 96, 0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fill();

                // Draw robot triangle
                ctx.fillStyle = '#e94560';
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.lineTo(-10, 10);
                ctx.lineTo(10, 10);
                ctx.closePath();
                ctx.fill();

                // Robot border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();

                // Draw coordinate info on map
                ctx.fillStyle = '#e94560';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`로봇: (${currentPose.x.toFixed(2)}, ${currentPose.y.toFixed(2)})`, 10, canvas.height - 10);
            }
        }

        // Jog dial initialized flag
        let jogDialInitialized = false;

        // Initialize jog dial event listeners
        function initJogDial() {
            if (jogDialInitialized) {
                console.log('Jog dial already initialized');
                return;
            }

            const jogDial = document.getElementById('jogDial');
            if (!jogDial) {
                console.log('jogDial element not found');
                return;
            }

            const buttons = jogDial.querySelectorAll('.jog-btn');
            console.log('Found jog buttons:', buttons.length);

            buttons.forEach((btn, index) => {
                const direction = btn.dataset.direction;
                console.log(`Button ${index}: direction=${direction}`);
                if (!direction) return;

                if (direction === 'stop') {
                    btn.onclick = (e) => {
                        e.preventDefault();
                        console.log('Stop button clicked');
                        stopJog();
                    };
                } else {
                    // Use onclick for simple click-based movement
                    btn.onmousedown = (e) => {
                        e.preventDefault();
                        console.log('Mousedown:', direction);
                        startJog(direction);
                    };
                    btn.onmouseup = (e) => {
                        e.preventDefault();
                        console.log('Mouseup');
                        stopJog();
                    };
                    btn.onmouseleave = () => {
                        if (jogInterval) {
                            console.log('Mouseleave - stopping');
                            stopJog();
                        }
                    };

                    // Touch events for mobile
                    btn.ontouchstart = (e) => {
                        e.preventDefault();
                        console.log('Touchstart:', direction);
                        startJog(direction);
                    };
                    btn.ontouchend = (e) => {
                        e.preventDefault();
                        console.log('Touchend');
                        stopJog();
                    };
                }
            });

            jogDialInitialized = true;
            log('조그 다이얼 초기화 완료', 'info');
            console.log('Jog dial initialized successfully');
        }

        // Jog control functions
        let isJogging = false;

        function startJog(direction) {
            // Prevent multiple simultaneous jogs
            if (isJogging) return;
            isJogging = true;

            log(`조그 시작: ${direction}`, 'info');

            // Send single move/turn command
            sendJogCommand(direction);
        }

        function stopJog() {
            if (jogInterval) {
                clearInterval(jogInterval);
                jogInterval = null;
            }
            isJogging = false;

            // Send stop command
            apiCall('cmd/speed', 'POST', { vx: 0, vth: 0 }).catch(() => {});
        }

        async function sendJogCommand(direction) {
            // Calculate distance/angle based on speed setting
            // jogSpeed is 0.1 to 0.5 m/s, use it as movement distance in cm (10-50cm)
            const moveDist = Math.round(jogSpeed * 50);  // 5-25 cm per press
            const turnAngle = Math.round(jogSpeed * 50); // 5-25 degrees per press
            const moveSpeed = 0.3;  // Fixed movement speed

            try {
                let endpoint, payload;

                switch(direction) {
                    case 'forward':
                        endpoint = 'cmd/move';
                        payload = { distance: moveDist, direction: 1, speed: moveSpeed };
                        break;
                    case 'backward':
                        endpoint = 'cmd/move';
                        payload = { distance: moveDist, direction: 0, speed: moveSpeed };
                        break;
                    case 'left':
                        // Turn left instead of strafe (most robots don't support strafe)
                        endpoint = 'cmd/turn';
                        payload = { direction: 1, angle: turnAngle, speed: moveSpeed };
                        break;
                    case 'right':
                        // Turn right
                        endpoint = 'cmd/turn';
                        payload = { direction: 0, angle: turnAngle, speed: moveSpeed };
                        break;
                    case 'rotate-left':
                        endpoint = 'cmd/turn';
                        payload = { direction: 1, angle: turnAngle, speed: moveSpeed };
                        break;
                    case 'rotate-right':
                        endpoint = 'cmd/turn';
                        payload = { direction: 0, angle: turnAngle, speed: moveSpeed };
                        break;
                    default:
                        console.log('Unknown direction:', direction);
                        isJogging = false;
                        return;
                }

                console.log(`Sending jog: ${endpoint}`, payload);

                // Use fetch directly for better error handling
                const response = await fetch(`${API_BASE}/${endpoint}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const responseText = await response.text();
                console.log(`Jog response (${response.status}):`, responseText);

                if (response.ok) {
                    try {
                        const result = JSON.parse(responseText);
                        if (result.status === 'success') {
                            log(`이동 명령 성공: ${direction}`, 'success');
                        }
                    } catch (e) {
                        // Response might not be JSON
                    }
                } else {
                    log(`이동 명령 실패: ${response.status}`, 'error');
                }

                // Reset jogging flag after command completes
                setTimeout(() => {
                    isJogging = false;
                }, 500);
            } catch (error) {
                console.log('Jog command error:', error);
                log(`이동 오류: ${error.message}`, 'error');
                isJogging = false;
            }
        }

        // Update jog speed
        function updateJogSpeed(value) {
            jogSpeed = parseFloat(value);
            document.getElementById('jogSpeedValue').textContent = jogSpeed.toFixed(2);
        }

        // Capture waypoint at current position
        async function captureWaypoint() {
            const name = document.getElementById('capturePointName').value.trim();
            const isChargingDock = document.getElementById('isChargingDock').checked;
            const waypointType = isChargingDock ? 'charge' : 'delivery';

            if (!name) {
                log('위치 이름을 입력하세요', 'error');
                return;
            }

            // Check if name already exists
            if (capturedPoints.some(p => p.name === name)) {
                log('이미 존재하는 이름입니다', 'error');
                return;
            }

            try {
                // Get current position
                const pose = await apiCall('reeman/pose');

                // Add to captured points
                capturedPoints.push({
                    name: name,
                    type: waypointType,
                    pose: {
                        x: pose.x,
                        y: pose.y,
                        theta: pose.theta
                    }
                });

                // Save to AMR
                const result = await apiCall('cmd/position', 'POST', {
                    name: name,
                    type: waypointType,
                    pose: {
                        x: pose.x,
                        y: pose.y,
                        theta: pose.theta
                    }
                });

                if (result.status === 'success') {
                    const typeLabel = isChargingDock ? '충전 도크' : '위치';
                    log(`${typeLabel} "${name}" 저장됨 (x: ${pose.x.toFixed(2)}, y: ${pose.y.toFixed(2)})`, 'success');
                    speakSafe(`${name} ${typeLabel}를 저장했습니다`);
                } else {
                    log(`위치 저장 실패: ${JSON.stringify(result)}`, 'error');
                }

                // Clear input and checkbox
                document.getElementById('capturePointName').value = '';
                document.getElementById('isChargingDock').checked = false;

                // Update UI
                renderCapturedPoints();

            } catch (error) {
                log(`위치 저장 오류: ${error.message}`, 'error');
            }
        }

        // Render captured points list
        function renderCapturedPoints() {
            const container = document.getElementById('capturedPointsList');
            const countEl = document.getElementById('capturedPointsCount');

            countEl.textContent = capturedPoints.length;

            if (capturedPoints.length === 0) {
                container.innerHTML = `
                    <div style="color: #a0a0a0; text-align: center; padding: 10px; font-size: 0.9em;">
                        아직 저장된 위치가 없습니다
                    </div>`;
                return;
            }

            container.innerHTML = capturedPoints.map((point, index) => `
                <div class="captured-point-item">
                    <div>
                        <div>${point.name}</div>
                        <div class="coords">x: ${point.pose.x.toFixed(2)}, y: ${point.pose.y.toFixed(2)}</div>
                    </div>
                    <button class="remove-captured" onclick="removeCapturedPoint(${index})">×</button>
                </div>
            `).join('');
        }

        // Remove captured point
        async function removeCapturedPoint(index) {
            const point = capturedPoints[index];

            if (!confirm(`"${point.name}" 위치를 삭제하시겠습니까?`)) {
                return;
            }

            try {
                // Delete from AMR
                await fetch(`${API_BASE}/cmd/position`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify([point.name])
                });

                // Remove from local array
                capturedPoints.splice(index, 1);
                renderCapturedPoints();

                log(`위치 "${point.name}" 삭제됨`, 'success');
            } catch (error) {
                log(`삭제 오류: ${error.message}`, 'error');
            }
        }

        // Start new mapping session on AMR
        async function startNewMapping() {
            if (!confirm('새로운 지도를 시작하시겠습니까?\n\n현재 AMR의 지도가 초기화됩니다.\n로봇을 새로운 시작 위치에 놓고 시작하세요.')) {
                return;
            }

            try {
                log('새 지도 시작 중...', 'info');

                // Set to mapping mode (mode 1)
                const modeResult = await apiCall('cmd/set_mode', 'POST', { mode: 1 });
                console.log('Set mode result:', modeResult);

                // Clear local state
                capturedPoints = [];
                robotPath = [];
                lastBuildPose = null;
                buildMapBounds = { minX: -2, maxX: 2, minY: -2, maxY: 2 };
                slamMapImage = null;
                slamMapInfo = null;

                renderCapturedPoints();

                // Wait a moment for mode to switch
                await new Promise(resolve => setTimeout(resolve, 1000));

                // Fetch fresh map
                await fetchSlamMap();

                log('새 지도 시작됨! 로봇을 움직여 지도를 만드세요.', 'success');
                speakSafe('새 지도 시작. 로봇을 움직여 지도를 만드세요.');

            } catch (error) {
                log(`새 지도 시작 실패: ${error.message}`, 'error');
            }
        }

        // Reset build map (local only)
        function resetBuildMap() {
            if (!confirm('화면의 경로와 위치를 초기화하시겠습니까?\n(AMR의 지도는 유지됩니다)')) {
                return;
            }

            capturedPoints = [];
            robotPath = [];
            lastBuildPose = null;
            renderCapturedPoints();
            initBuildMapCanvas();

            log('화면 초기화됨', 'info');
        }

        // Save map to AMR
        async function saveBuildMap() {
            const name = prompt('AMR에 저장할 지도 이름을 입력하세요:');

            if (!name || !name.trim()) {
                return;
            }

            try {
                log('지도 저장 중...', 'info');

                // Save map to AMR
                const result = await apiCall('cmd/save_map', 'POST', { map_name: name.trim() });
                console.log('Save map result:', result);

                if (result.status === 'success') {
                    log(`지도 "${name}" AMR에 저장됨`, 'success');
                    speakSafe(`지도 ${name}이 저장되었습니다`);

                    // Also save locally
                    savedMaps[name.trim()] = {
                        name: name.trim(),
                        points: [...capturedPoints],
                        path: [...robotPath],
                        createdAt: new Date().toISOString()
                    };
                    saveMapsToStorage();

                    // Switch back to navigation mode
                    await apiCall('cmd/set_mode', 'POST', { mode: 2 });
                    log('네비게이션 모드로 전환됨', 'info');
                } else {
                    log(`지도 저장 실패: ${JSON.stringify(result)}`, 'error');
                }
            } catch (error) {
                log(`지도 저장 오류: ${error.message}`, 'error');
            }
        }

        // Load saved maps from localStorage
        function loadSavedMaps() {
            const saved = localStorage.getItem('docentMaps');
            if (saved) {
                savedMaps = JSON.parse(saved);
            }
        }

        // Save maps to localStorage
        function saveMapsToStorage() {
            localStorage.setItem('docentMaps', JSON.stringify(savedMaps));
        }

        // Open saved maps modal
        function openSavedMapsModal() {
            renderSavedMapsList();
            document.getElementById('savedMapsModal').classList.add('show');
        }

        // Close saved maps modal
        function closeSavedMapsModal() {
            document.getElementById('savedMapsModal').classList.remove('show');
            selectedMapName = null;
        }

        // Render saved maps list
        function renderSavedMapsList() {
            const container = document.getElementById('savedMapsList');
            const mapNames = Object.keys(savedMaps);

            if (mapNames.length === 0) {
                container.innerHTML = `
                    <div style="color: #a0a0a0; text-align: center; padding: 20px;">
                        저장된 지도가 없습니다
                    </div>`;
                return;
            }

            container.innerHTML = mapNames.map(name => {
                const map = savedMaps[name];
                const date = new Date(map.createdAt).toLocaleDateString('ko-KR');
                const isSelected = selectedMapName === name;

                return `
                    <div class="saved-map-item ${isSelected ? 'active' : ''}" onclick="selectMap('${name}')">
                        <div class="map-info">
                            <div class="map-name">${name}</div>
                            <div class="map-date">${date}</div>
                        </div>
                        <div class="map-points-count">${map.points.length}개 위치</div>
                    </div>
                `;
            }).join('');
        }

        // Select map from list
        function selectMap(name) {
            selectedMapName = name;
            renderSavedMapsList();
        }

        // Load selected map
        function loadSelectedMap() {
            if (!selectedMapName || !savedMaps[selectedMapName]) {
                log('지도를 선택하세요', 'error');
                return;
            }

            const map = savedMaps[selectedMapName];
            capturedPoints = [...map.points];
            robotPath = map.path ? [...map.path] : [];

            renderCapturedPoints();
            initBuildMapCanvas();

            closeSavedMapsModal();
            log(`지도 "${selectedMapName}" 불러옴`, 'success');
        }

        // Handle window resize for build map canvas
        window.addEventListener('resize', () => {
            if (document.getElementById('buildMapModal').classList.contains('show')) {
                initBuildMapCanvas();
            }
        });
    </script>
</body>
</html>
